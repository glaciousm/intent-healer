package com.intenthealer.cucumber.generator;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Generates step definition classes with Intent Healer annotations.
 *
 * Features:
 * - Parses Gherkin feature files
 * - Generates Java step definition classes
 * - Adds @Intent and @Outcome annotations
 * - Generates Page Object patterns
 * - Supports multiple UI frameworks (Selenium, etc.)
 */
public class StepDefinitionGenerator {

    private static final Logger logger = LoggerFactory.getLogger(StepDefinitionGenerator.class);

    // Gherkin step patterns
    private static final Pattern STEP_PATTERN = Pattern.compile(
            "^\\s*(Given|When|Then|And|But)\\s+(.+)$", Pattern.MULTILINE);
    private static final Pattern PARAM_PATTERN = Pattern.compile("\"([^\"]+)\"|'([^']+)'|<([^>]+)>|(\\d+)");
    private static final Pattern SCENARIO_PATTERN = Pattern.compile(
            "^\\s*Scenario(?: Outline)?:\\s*(.+)$", Pattern.MULTILINE);
    private static final Pattern FEATURE_PATTERN = Pattern.compile(
            "^\\s*Feature:\\s*(.+)$", Pattern.MULTILINE);

    private final GeneratorConfig config;
    private final Set<String> generatedSteps;

    public StepDefinitionGenerator() {
        this(GeneratorConfig.defaults());
    }

    public StepDefinitionGenerator(GeneratorConfig config) {
        this.config = config;
        this.generatedSteps = new HashSet<>();
    }

    /**
     * Generate step definitions from a feature file.
     */
    public GeneratedCode generateFromFeature(Path featurePath) throws IOException {
        String content = Files.readString(featurePath);
        return generateFromContent(content, featurePath.getFileName().toString());
    }

    /**
     * Generate step definitions from feature content.
     */
    public GeneratedCode generateFromContent(String featureContent, String sourceName) {
        // Extract feature name
        String featureName = extractFeatureName(featureContent);

        // Extract all steps
        List<StepInfo> steps = extractSteps(featureContent);

        // Generate class
        String className = toClassName(featureName) + "Steps";
        String packageName = config.basePackage();

        StringBuilder code = new StringBuilder();

        // Package and imports
        code.append("package ").append(packageName).append(";\n\n");
        code.append(generateImports());
        code.append("\n");

        // Class documentation
        code.append("/**\n");
        code.append(" * Auto-generated step definitions for: ").append(featureName).append("\n");
        code.append(" * Source: ").append(sourceName).append("\n");
        code.append(" * \n");
        code.append(" * Generated by Intent Healer Step Definition Generator\n");
        code.append(" */\n");

        // Class declaration
        code.append("public class ").append(className).append(" {\n\n");

        // Fields
        code.append("    private final WebDriver driver;\n");
        if (config.generatePageObjects()) {
            code.append("    private final ").append(toClassName(featureName)).append("Page page;\n");
        }
        code.append("\n");

        // Constructor
        code.append("    public ").append(className).append("(WebDriver driver) {\n");
        code.append("        this.driver = driver;\n");
        if (config.generatePageObjects()) {
            code.append("        this.page = new ").append(toClassName(featureName)).append("Page(driver);\n");
        }
        code.append("    }\n\n");

        // Generate step methods
        Set<String> processedPatterns = new HashSet<>();
        for (StepInfo step : steps) {
            String pattern = step.toPattern();
            if (!processedPatterns.contains(pattern)) {
                code.append(generateStepMethod(step));
                code.append("\n");
                processedPatterns.add(pattern);
            }
        }

        code.append("}\n");

        // Generate page object if configured
        String pageObjectCode = null;
        if (config.generatePageObjects()) {
            pageObjectCode = generatePageObject(featureName, steps);
        }

        return new GeneratedCode(
                className,
                packageName,
                code.toString(),
                pageObjectCode,
                steps.size()
        );
    }

    /**
     * Generate step definitions for multiple features.
     */
    public List<GeneratedCode> generateFromDirectory(Path featuresDir) throws IOException {
        List<GeneratedCode> results = new ArrayList<>();

        try (var stream = Files.walk(featuresDir)) {
            List<Path> featureFiles = stream
                    .filter(p -> p.toString().endsWith(".feature"))
                    .toList();

            for (Path featurePath : featureFiles) {
                try {
                    results.add(generateFromFeature(featurePath));
                } catch (Exception e) {
                    logger.warn("Failed to process {}: {}", featurePath, e.getMessage());
                }
            }
        }

        return results;
    }

    /**
     * Save generated code to files.
     */
    public void saveToFiles(GeneratedCode code, Path outputDir) throws IOException {
        Path packageDir = outputDir.resolve(code.packageName().replace('.', '/'));
        Files.createDirectories(packageDir);

        // Save step definition class
        Path stepFile = packageDir.resolve(code.className() + ".java");
        Files.writeString(stepFile, code.stepDefinitionCode());
        logger.info("Generated step definitions: {}", stepFile);

        // Save page object if present
        if (code.pageObjectCode() != null) {
            String pageClassName = code.className().replace("Steps", "Page");
            Path pageFile = packageDir.resolve(pageClassName + ".java");
            Files.writeString(pageFile, code.pageObjectCode());
            logger.info("Generated page object: {}", pageFile);
        }
    }

    private String extractFeatureName(String content) {
        Matcher matcher = FEATURE_PATTERN.matcher(content);
        return matcher.find() ? matcher.group(1).trim() : "Unknown";
    }

    private List<StepInfo> extractSteps(String content) {
        List<StepInfo> steps = new ArrayList<>();
        String currentScenario = "Unknown";

        // First find scenario for context
        Matcher scenarioMatcher = SCENARIO_PATTERN.matcher(content);
        List<int[]> scenarioPositions = new ArrayList<>();
        while (scenarioMatcher.find()) {
            scenarioPositions.add(new int[]{scenarioMatcher.start(), scenarioMatcher.end()});
        }

        Matcher stepMatcher = STEP_PATTERN.matcher(content);
        while (stepMatcher.find()) {
            String keyword = stepMatcher.group(1);
            String text = stepMatcher.group(2).trim();

            // Find which scenario this belongs to
            int stepPos = stepMatcher.start();
            for (int i = scenarioPositions.size() - 1; i >= 0; i--) {
                if (scenarioPositions.get(i)[0] < stepPos) {
                    Matcher sm = SCENARIO_PATTERN.matcher(content.substring(scenarioPositions.get(i)[0]));
                    if (sm.find()) {
                        currentScenario = sm.group(1).trim();
                    }
                    break;
                }
            }

            steps.add(new StepInfo(keyword, text, currentScenario, extractParameters(text)));
        }

        return steps;
    }

    private List<ParameterInfo> extractParameters(String stepText) {
        List<ParameterInfo> params = new ArrayList<>();
        Matcher matcher = PARAM_PATTERN.matcher(stepText);
        int index = 0;

        while (matcher.find()) {
            String value = matcher.group(1); // quoted string
            if (value == null) value = matcher.group(2); // single quoted
            if (value == null) value = matcher.group(3); // angle brackets
            if (value == null) value = matcher.group(4); // number

            ParameterType type = ParameterType.STRING;
            if (matcher.group(4) != null) {
                type = ParameterType.INT;
            }

            String name = inferParameterName(value, index);
            params.add(new ParameterInfo(name, type, value));
            index++;
        }

        return params;
    }

    private String inferParameterName(String value, int index) {
        if (value == null) return "param" + index;

        // Try to infer from common patterns
        String lower = value.toLowerCase();
        if (lower.contains("user") || lower.contains("name")) return "username";
        if (lower.contains("pass") || lower.contains("secret")) return "password";
        if (lower.contains("email") || lower.contains("@")) return "email";
        if (lower.contains("button") || lower.contains("click")) return "buttonText";
        if (lower.contains("url") || lower.contains("http")) return "url";
        if (lower.contains("text") || lower.contains("message")) return "text";

        return "param" + index;
    }

    private String generateImports() {
        StringBuilder imports = new StringBuilder();
        imports.append("import io.cucumber.java.en.*;\n");
        imports.append("import org.openqa.selenium.WebDriver;\n");
        imports.append("import org.openqa.selenium.WebElement;\n");
        imports.append("import org.openqa.selenium.By;\n");
        imports.append("import org.openqa.selenium.support.ui.WebDriverWait;\n");
        imports.append("import org.openqa.selenium.support.ui.ExpectedConditions;\n");
        imports.append("import com.intenthealer.cucumber.annotations.Intent;\n");
        imports.append("import com.intenthealer.cucumber.annotations.Outcome;\n");
        imports.append("import java.time.Duration;\n");
        imports.append("import static org.assertj.core.api.Assertions.assertThat;\n");
        return imports.toString();
    }

    private String generateStepMethod(StepInfo step) {
        StringBuilder method = new StringBuilder();

        // Intent annotation
        method.append("    @Intent(\"").append(escapeString(step.generateIntent())).append("\")\n");

        // Outcome annotation if applicable
        if (step.keyword().equals("Then")) {
            method.append("    @Outcome(\"").append(escapeString(step.generateOutcome())).append("\")\n");
        }

        // Cucumber annotation
        String annotationName = step.keyword().equals("And") || step.keyword().equals("But")
                ? "Given" : step.keyword();
        method.append("    @").append(annotationName).append("(\"").append(step.toPattern()).append("\")\n");

        // Method signature
        String methodName = toMethodName(step.text());
        method.append("    public void ").append(methodName).append("(");

        // Parameters
        List<String> paramDecls = new ArrayList<>();
        for (ParameterInfo param : step.parameters()) {
            String type = param.type() == ParameterType.INT ? "int" : "String";
            paramDecls.add(type + " " + param.name());
        }
        method.append(String.join(", ", paramDecls));
        method.append(") {\n");

        // Method body
        method.append(generateMethodBody(step));

        method.append("    }\n");
        return method.toString();
    }

    private String generateMethodBody(StepInfo step) {
        StringBuilder body = new StringBuilder();
        String text = step.text().toLowerCase();

        // Generate body based on step patterns
        if (text.contains("navigate") || text.contains("go to") || text.contains("open")) {
            body.append("        // Navigate to URL\n");
            if (step.parameters().isEmpty()) {
                body.append("        // TODO: Add URL parameter to step definition\n");
                body.append("        driver.get(\"https://example.com\");\n");
            } else {
                // Check if the parameter looks like a URL
                String paramName = step.parameters().get(0).name();
                String paramValue = step.parameters().get(0).value();
                if (paramValue != null && (paramValue.startsWith("http://") || paramValue.startsWith("https://") ||
                    paramValue.contains("www.") || paramName.toLowerCase().contains("url"))) {
                    body.append("        driver.get(").append(paramName).append(");\n");
                } else {
                    body.append("        driver.get(").append(paramName).append(");\n");
                }
            }
        } else if (text.contains("click")) {
            body.append("        // Click element\n");
            body.append("        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n");
            if (!step.parameters().isEmpty()) {
                body.append("        WebElement element = wait.until(ExpectedConditions.elementToBeClickable(\n");
                body.append("            By.xpath(\"//*[contains(text(),'\" + ").append(step.parameters().get(0).name()).append(" + \"')]\")));\n");
            } else {
                // Extract button text from step text using regex
                String buttonText = extractButtonTextFromStep(step.text());
                body.append("        WebElement element = wait.until(ExpectedConditions.elementToBeClickable(\n");
                body.append("            By.xpath(\"//button[contains(text(),'").append(buttonText).append("')]\")));\n");
            }
            body.append("        element.click();\n");
        } else if (text.contains("enter") || text.contains("type") || text.contains("fill") || text.contains("input")) {
            body.append("        // Enter text into field\n");
            body.append("        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n");
            if (step.parameters().size() >= 2) {
                body.append("        WebElement field = wait.until(ExpectedConditions.visibilityOfElementLocated(\n");
                body.append("            By.xpath(\"//input[@placeholder='\" + ").append(step.parameters().get(0).name()).append(" + \"']\")));\n");
                body.append("        field.clear();\n");
                body.append("        field.sendKeys(").append(step.parameters().get(1).name()).append(");\n");
            } else if (step.parameters().size() == 1) {
                body.append("        WebElement field = wait.until(ExpectedConditions.visibilityOfElementLocated(\n");
                body.append("            By.xpath(\"//input[@type='text']\")));\n");
                body.append("        field.clear();\n");
                body.append("        field.sendKeys(").append(step.parameters().get(0).name()).append(");\n");
            } else {
                // Generate a more intelligent default based on step text
                String fieldHint = extractFieldHintFromStep(step.text());
                body.append("        // TODO: Add appropriate locator for '").append(fieldHint).append("' field\n");
                body.append("        WebElement field = wait.until(ExpectedConditions.visibilityOfElementLocated(\n");
                body.append("            By.xpath(\"//input[@type='text']\")));\n");
                body.append("        field.clear();\n");
                body.append("        field.sendKeys(\"test value\");\n");
            }
        } else if (text.contains("see") || text.contains("displayed") || text.contains("visible") || text.contains("should")) {
            body.append("        // Verify element visibility\n");
            body.append("        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n");
            if (!step.parameters().isEmpty()) {
                body.append("        WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(\n");
                body.append("            By.xpath(\"//*[contains(text(),'\" + ").append(step.parameters().get(0).name()).append(" + \"')]\")));\n");
                body.append("        assertThat(element.isDisplayed()).isTrue();\n");
            } else {
                // Generate a default assertion using step text
                String assertionHint = extractAssertionHintFromStep(step.text());
                body.append("        // Verify: ").append(assertionHint).append("\n");
                body.append("        WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(\n");
                body.append("            By.xpath(\"//*[contains(text(),'").append(escapeString(assertionHint)).append("')]\")));\n");
                body.append("        assertThat(element.isDisplayed()).isTrue();\n");
            }
        } else if (text.contains("select") || text.contains("choose")) {
            body.append("        // Select from dropdown\n");
            body.append("        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n");
            if (step.parameters().size() >= 2) {
                // First param is option, second is dropdown identifier
                body.append("        WebElement dropdown = wait.until(ExpectedConditions.elementToBeClickable(\n");
                body.append("            By.xpath(\"//select[contains(@name,'\" + ").append(step.parameters().get(1).name()).append(" + \"')]\")));\n");
                body.append("        org.openqa.selenium.support.ui.Select select = new org.openqa.selenium.support.ui.Select(dropdown);\n");
                body.append("        select.selectByVisibleText(").append(step.parameters().get(0).name()).append(");\n");
            } else if (step.parameters().size() == 1) {
                body.append("        WebElement dropdown = wait.until(ExpectedConditions.elementToBeClickable(\n");
                body.append("            By.xpath(\"//select\")));\n");
                body.append("        org.openqa.selenium.support.ui.Select select = new org.openqa.selenium.support.ui.Select(dropdown);\n");
                body.append("        select.selectByVisibleText(").append(step.parameters().get(0).name()).append(");\n");
            } else {
                body.append("        // TODO: Add dropdown locator and option\n");
                body.append("        throw new io.cucumber.java.PendingException();\n");
            }
        } else if (text.contains("wait")) {
            body.append("        // Wait for condition\n");
            body.append("        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n");
            if (!step.parameters().isEmpty()) {
                // Try to determine what to wait for based on step text
                if (text.contains("visible") || text.contains("appear")) {
                    body.append("        wait.until(ExpectedConditions.visibilityOfElementLocated(\n");
                    body.append("            By.xpath(\"//*[contains(text(),'\" + ").append(step.parameters().get(0).name()).append(" + \"')]\")));\n");
                } else if (text.contains("clickable")) {
                    body.append("        wait.until(ExpectedConditions.elementToBeClickable(\n");
                    body.append("            By.xpath(\"//*[contains(text(),'\" + ").append(step.parameters().get(0).name()).append(" + \"')]\")));\n");
                } else if (text.contains("disappear") || text.contains("invisible")) {
                    body.append("        wait.until(ExpectedConditions.invisibilityOfElementLocated(\n");
                    body.append("            By.xpath(\"//*[contains(text(),'\" + ").append(step.parameters().get(0).name()).append(" + \"')]\")));\n");
                } else {
                    body.append("        wait.until(ExpectedConditions.presenceOfElementLocated(\n");
                    body.append("            By.xpath(\"//*[contains(text(),'\" + ").append(step.parameters().get(0).name()).append(" + \"')]\")));\n");
                }
            } else {
                // Extract time if present, otherwise use generic wait
                Integer waitSeconds = extractWaitTimeFromStep(step.text());
                if (waitSeconds != null) {
                    body.append("        Thread.sleep(").append(waitSeconds * 1000).append(");\n");
                } else {
                    body.append("        // TODO: Specify what condition to wait for\n");
                    body.append("        Thread.sleep(2000);\n");
                }
            }
        } else {
            body.append("        // TODO: Implement step logic\n");
            body.append("        throw new io.cucumber.java.PendingException();\n");
        }

        return body.toString();
    }

    private String generatePageObject(String featureName, List<StepInfo> steps) {
        String className = toClassName(featureName) + "Page";

        StringBuilder code = new StringBuilder();
        code.append("package ").append(config.basePackage()).append(";\n\n");
        code.append("import org.openqa.selenium.WebDriver;\n");
        code.append("import org.openqa.selenium.WebElement;\n");
        code.append("import org.openqa.selenium.support.FindBy;\n");
        code.append("import org.openqa.selenium.support.PageFactory;\n\n");

        code.append("/**\n");
        code.append(" * Page object for: ").append(featureName).append("\n");
        code.append(" * Generated by Intent Healer\n");
        code.append(" */\n");
        code.append("public class ").append(className).append(" {\n\n");

        code.append("    private final WebDriver driver;\n\n");

        // Extract potential elements from steps
        Set<String> elements = new LinkedHashSet<>();
        for (StepInfo step : steps) {
            for (ParameterInfo param : step.parameters()) {
                if (param.type() == ParameterType.STRING && param.value() != null) {
                    elements.add(param.value());
                }
            }
        }

        // Generate element fields
        for (String element : elements) {
            String fieldName = toFieldName(element);
            code.append("    @FindBy(xpath = \"//*[contains(text(),'").append(escapeString(element)).append("')]\")\n");
            code.append("    private WebElement ").append(fieldName).append(";\n\n");
        }

        // Constructor
        code.append("    public ").append(className).append("(WebDriver driver) {\n");
        code.append("        this.driver = driver;\n");
        code.append("        PageFactory.initElements(driver, this);\n");
        code.append("    }\n\n");

        // Getter methods
        for (String element : elements) {
            String fieldName = toFieldName(element);
            String methodName = "get" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);
            code.append("    public WebElement ").append(methodName).append("() {\n");
            code.append("        return ").append(fieldName).append(";\n");
            code.append("    }\n\n");
        }

        code.append("}\n");
        return code.toString();
    }

    private String toClassName(String text) {
        // First replace special characters with spaces so they become word separators
        String normalized = text.replaceAll("[^a-zA-Z0-9\\s_-]", " ");
        return Arrays.stream(normalized.split("[\\s_-]+"))
                .filter(word -> !word.isEmpty())
                .map(word -> Character.toUpperCase(word.charAt(0)) + word.substring(1).toLowerCase())
                .collect(Collectors.joining());
    }

    private String toMethodName(String text) {
        String cleaned = text.replaceAll("\"[^\"]*\"", "param")
                .replaceAll("'[^']*'", "param")
                .replaceAll("<[^>]*>", "param")
                .replaceAll("\\d+", "num");

        String[] words = cleaned.split("[\\s_-]+");
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < words.length; i++) {
            String word = words[i].replaceAll("[^a-zA-Z0-9]", "");
            if (word.isEmpty()) continue;
            if (i == 0) {
                result.append(word.toLowerCase());
            } else {
                result.append(Character.toUpperCase(word.charAt(0)));
                if (word.length() > 1) result.append(word.substring(1).toLowerCase());
            }
        }
        return result.toString();
    }

    private String toFieldName(String text) {
        String name = toMethodName(text);
        return name.isEmpty() ? "element" : name + "Element";
    }

    private String escapeString(String text) {
        return text.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n");
    }

    private String extractButtonTextFromStep(String stepText) {
        // Try to extract text that looks like a button label
        // Look for common patterns like "click the X button", "click X", etc.
        String lower = stepText.toLowerCase();

        // Remove common prefixes
        String cleaned = lower
                .replaceFirst("^i\\s+", "")
                .replaceFirst("^click\\s+(?:the\\s+)?", "")
                .replaceFirst("^on\\s+(?:the\\s+)?", "")
                .replaceFirst("button$", "")
                .trim();

        if (!cleaned.isEmpty()) {
            return cleaned.substring(0, 1).toUpperCase() + cleaned.substring(1);
        }
        return "Submit";
    }

    private String extractFieldHintFromStep(String stepText) {
        // Extract a hint about what field we're interacting with
        String lower = stepText.toLowerCase();

        // Look for common field indicators
        if (lower.contains("username") || lower.contains("user name")) return "username";
        if (lower.contains("password") || lower.contains("passwd")) return "password";
        if (lower.contains("email")) return "email";
        if (lower.contains("search")) return "search";
        if (lower.contains("name")) return "name";

        // Generic fallback
        return "input field";
    }

    private String extractAssertionHintFromStep(String stepText) {
        // Extract what we should be asserting
        String cleaned = stepText
                .replaceFirst("(?i)^i\\s+should\\s+", "")
                .replaceFirst("(?i)^i\\s+", "")
                .replaceFirst("(?i)^see\\s+", "")
                .replaceFirst("(?i)^the\\s+", "")
                .trim();

        if (!cleaned.isEmpty()) {
            return cleaned;
        }
        return "expected content";
    }

    private Integer extractWaitTimeFromStep(String stepText) {
        // Try to extract a number of seconds from the step text
        Pattern timePattern = Pattern.compile("(\\d+)\\s*(?:second|sec)s?", Pattern.CASE_INSENSITIVE);
        Matcher matcher = timePattern.matcher(stepText);

        if (matcher.find()) {
            return Integer.parseInt(matcher.group(1));
        }
        return null;
    }

    // Records
    public record StepInfo(
            String keyword,
            String text,
            String scenario,
            List<ParameterInfo> parameters
    ) {
        public String toPattern() {
            String pattern = text;
            pattern = pattern.replaceAll("\"[^\"]*\"", "\"{string}\"");
            pattern = pattern.replaceAll("'[^']*'", "'{string}'");
            pattern = pattern.replaceAll("<[^>]+>", "{string}");
            pattern = pattern.replaceAll("\\b\\d+\\b", "{int}");
            return pattern;
        }

        public String generateIntent() {
            return "User " + text.toLowerCase()
                    .replaceAll("i\\s+", "")
                    .replaceAll("\"[^\"]*\"", "the specified value")
                    .replaceAll("'[^']*'", "the specified value");
        }

        public String generateOutcome() {
            return "Verify " + text.toLowerCase()
                    .replaceAll("i should\\s+", "")
                    .replaceAll("\"[^\"]*\"", "expected content");
        }
    }

    public record ParameterInfo(String name, ParameterType type, String value) {}

    public enum ParameterType { STRING, INT }

    public record GeneratedCode(
            String className,
            String packageName,
            String stepDefinitionCode,
            String pageObjectCode,
            int stepCount
    ) {}

    public record GeneratorConfig(
            String basePackage,
            boolean generatePageObjects,
            boolean generateIntentAnnotations,
            boolean generateOutcomeAnnotations
    ) {
        public static GeneratorConfig defaults() {
            return new GeneratorConfig(
                    "com.example.steps",
                    true,
                    true,
                    true
            );
        }
    }
}
